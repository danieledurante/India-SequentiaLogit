---
title: "Estimation and Results"
author: "Tommaso Rigon"
output: 
  html_document: 
    keep_md: yes
    theme: cerulean
---

## Description

In this tutorial we describe how to estimate the model we described in Section 3 of our paper. We implemented our algorithm in R, making use of the `Rcpp` and `RcppArmadillo` for the most computationally intensive steps. The [R code]() is made available as well as the [C++]() code.

The Gibbs sampler for our model is contained in the function called `fit_logit`, which we will use extensively later on. As a first step, we load in memory all the required libraries and we compile the C++ code. Moreover, we load in memory also the [previously cleaned](https://github.com/tommasorigon/India-SequentiaLogit/blob/master/data-cleaning.md) dataset.

The functions `logit_ranef`, `logit_ranef_spline` and `logit_ranefDP` allow to estimate the submodels described in Section 4.1 of the paper. The function `logit_ranefDP_spline` estimates the full model. All these functions are 

```{r loading functions,eval=FALSE}
library(BayesLogit)
library(splines)
library(Rcpp)
library(RcppArmadillo)

rm(list=ls())
load("dataset.RData")
sourceCpp("core_functions.cpp")
source("core_functions.R")
```

## Prior specification and estimation

The prior hyperparameters for all our models, discussed in Section 3 and Section 4.1 for the submodels, is specified through a list. Fixing `P_Fix_const = 1e-2` is equivalent to set ${\bf B} = \text{diag}(100,\dots,100)$.

```{r prior hyperparameters,eval=FALSE}
prior = list(P_Fix_const=1e-2, H=32,
             a_lambda=1e-3, b_lambda=1e-3,
             a_tau=1e-4, b_tau=1e-4, 
             a_alpha=.1, b_alpha=.1)
```

Then, we set the number of MCMC iterations equal to $R= 20'000$ with a burn-in equal to $2'000$. we also define two "formulas": one for the specification in which `age` enters in the predictor linearly and one in which `age` is modeled through Bayesian penalized splines.

```{r iterations and burn-in,eval=FALSE}
R       <- 20000
burn_in <- 2000

# Age enters in the predictor linearly
f   <- as.formula(target ~ age + child + area + religion + education)
# Age is absent, since it is modeled flexibly through Bayesian P-splines.
f_s <- as.formula(target ~ child + area + religion + education)
```

The estimation process **requires a non-negligible amount of time** to be completed. On standard laptop, this will need about 4-5 hours. We made available the [results of the MCMC chain](), which can be loaded without running the algorithm. 

#### 1. Usage choice

The model and the corresponding submodels for the usage choice are estimated below. 

```{r usage choice,message=FALSE,eval=FALSE}
set.seed(123) # We set a seed so that our results are fully reproducible.

# We define the target variable. 
dataset$target     <- factor(dataset$method!="1. No contraceptive method")

# Estimate the submodels
fit1_ranef         <- fit_logit(f,dataset$state,dataset$Age,dataset,method="ranef",prior,R,burn_in)
fit1_ranef_s       <- fit_logit(f_s,dataset$state,dataset$Age,dataset,method="ranef_s",prior,R,burn_in)
fit1_dp_ranef      <- fit_logit(f,dataset$state,dataset$Age,dataset,method="dp_ranef",prior,R,burn_in)

# Estimate the full model
fit1_dp_ranef_s    <- fit_logit(f_s,dataset$State,dataset$Age,dataset,method="dp_ranef_s",prior,R,burn_in)
```

#### 2. Reversible choice

We condition to a smaller dataset of observations and therefore we select only those women who are making use of contraception.

```{r reversible choice,message=FALSE,eval=FALSE}
set.seed(123) # We set a seed so that our results are fully reproducible.

# Subsetting observations
dataset2            <- dataset[dataset$method != "1. No contraceptive method",]

# We define the new target variable. 
dataset2$target     <- factor(dataset2$method != "2. Sterilization") # table(dataset2$target, dataset2$method)

# Estimate the submodels
fit2_ranef         <- fit_logit(f,dataset2$state,dataset2$age,dataset2,method="ranef",prior,R,burn_in)
fit2_ranef_s       <- fit_logit(f_s,dataset2$state,dataset2$age,dataset2,method="ranef_s",prior,R,burn_in)
fit2_dp_ranef      <- fit_logit(f,dataset2$state,dataset2$age,dataset2,method="dp_ranef",prior,R,burn_in)

# Estimate the full model
fit2_dp_ranef_s    <- fit_logit(f_s,dataset2$state,dataset2$age,dataset2,method="dp_ranef_s",prior,R,burn_in)
```


#### 3. Method choice

Finally for the method choice model we perform similar steps as before.

```{r method choice, message=FALSE,eval=FALSE}
set.seed(123) # We set a seed so that our results are fully reproducible.

# Subsetting observations
dataset3            <- dataset2[dataset2$method != "2. Sterilization",]

# We define the new target variable. 
dataset3$target     <- factor(dataset3$method == "4. Modern methods") # table(dataset3$target,dataset3$method)

# Estimate the submodels
fit3_ranef         <- fit_logit(f,dataset3$state,dataset3$age,dataset3,method="ranef",prior,R,burn_in)
fit3_ranef_s       <- fit_logit(f_s,dataset3$state,dataset3$age,dataset3,method="ranef_s",prior,R,burn_in)
fit3_dp_ranef      <- fit_logit(f,dataset3$state,dataset3$age,dataset3,method="dp_ranef",prior,R,burn_in)

# Estimate the full model
fit3_dp_ranef_s    <- fit_logit(f_s,dataset3$state,dataset3$age,dataset3,method="dp_ranef_s",prior,R,burn_in)
```



## Convergence diagnostic

## Results

#### Information criteria (DIC and WAIC)

#### Fixed effects

#### Age effect

#### Random effects: clustering and graphs



